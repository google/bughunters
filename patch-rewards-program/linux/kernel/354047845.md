### Improvement category


#### Submission title

Patch rewards submission patching Spectre attack in the Linux kernel


#### Please select the best-matching category:

Improvement to privilege separation or sandboxing


---

### Patch details


#### Specify project (the scope is limited to the listed projects):

Security-critical, commonly used components of the Linux kernel (including KVM)


#### Project name

Linux kernel


#### Patch name or short description

vt_ioctl: fix array_index_nospec() in vt_setactivate()


#### Links to the diffs of the patch

https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=61cc70d9e8ef5b042d4ed87994d20100ec8896d9


#### Complexity – select the option that best describes the patch's complexity:

Moderate effort or complexity


#### Impact – select the option that best describes the security impact of the patch:

Compelling security benefits


#### Tell us more about the patch

Over the time span of 2,5 years I've built a bug finding scanner for speculative execution bugs in the kernel that remained unpatched since the first occurrence of Spectre.

In the original version of Spectre (https://spectreattack.com/) a bounds check can be bypassed in speculative execution leaving traces in the cache and leak secret information to the attacker.

The feasibility of such attacks has been demonstrated by the wild spectre v1 exploit (https://dustri.org/b/spectre-exploits-in-the-wild.html) and imposes a real threat especially for colocated VMs / machines executing untrusted code.

Our work with Kasper in finding and patching those gadgets missed by manual inspection even inspired people at Google to do something similar (https://github.com/google/security-research/blob/master/pocs/cpus/spectre-gadgets/README.md)

In this patch specifically the mitigation was applied incorrectly even more difficult to spot without complex scanning tools since it is present but working incorrectly.

Since the speculative masking is done before decrementing the pointer, the value is set to 0 if the transient value is out-of-bounds. Decrementing it afterwards however creates a speculative underflow allowing an attacker to use the gadget to read potentially sensitive memory.

I've ranked the patch as "Moderate effort or complexity" since we've worked more than 2 years to build the bug scanner (https://www.vusec.net/projects/kasper/) and even evaluating the possible results takes significant effort and time to validate for true positives.